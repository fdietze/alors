use colored::Colorize;
use fancy_regex::Regex;
use once_cell::sync::Lazy;
use openrouter_api::models::tool::ToolCall;
use openrouter_api::types::chat::Message;
use std::fmt::Write;

static FILE_BLOCK_REGEX: Lazy<Regex> = Lazy::new(|| {
    // This regex captures the file path and content from the block format generated by prompt_builder.
    // (?s) allows . to match newlines.
    Regex::new(r"(?s)### `(?P<path>.+?)`\n```\n(?P<content>.*?)\n```\n---\n?").unwrap()
});

/// Formats a message into a string with nice formatting.
/// It collapses file content blocks for user messages to reduce noise.
pub fn pretty_print_message(message: &Message) -> String {
    let mut buffer = String::new();

    let role_text = message.role.as_str();
    let role_colored = match role_text {
        "tool" => {
            println!("!!! DEBUG: message: {:?}", message);
            let mut display = message.role.to_string();
            if let Some(tool_calls) = &message.tool_calls {
                write!(&mut display, " ({})", format_tool_calls_pretty(tool_calls)).unwrap();
            }
            display.red()
        }
        _ => message.role.to_string().blue(),
    };
    writeln!(&mut buffer, "\n[{role_colored}]").unwrap();

    if !message.content.is_empty() {
        let is_user = role_text == "user";
        let mut processed_content = message.content.clone();

        if is_user {
            processed_content = FILE_BLOCK_REGEX
                .replace_all(&message.content, |caps: &fancy_regex::Captures| {
                    let path = &caps["path"];
                    let content = &caps["content"];
                    let line_count = content.lines().count();
                    let summary = format!("[{path} ({line_count} lines)]");
                    // Add a newline to ensure each collapsed file is on its own line,
                    // and apply dimming directly.
                    format!("{}\n", summary.dimmed())
                })
                .to_string();
        }

        match role_text {
            "user" => {
                for line in processed_content.lines() {
                    // Pre-colored lines (our summaries) will not be re-colored.
                    // Other user prompt lines will be cyan.
                    // \x1B is the escape character for ANSI color codes.
                    if line.starts_with('\x1B') {
                        writeln!(&mut buffer, "{line}").unwrap();
                    } else {
                        writeln!(&mut buffer, "{}", line.cyan()).unwrap();
                    }
                }
            }
            _ => {
                // Assistant and other roles
                for line in processed_content.lines() {
                    writeln!(&mut buffer, "{line}").unwrap();
                }
            }
        }
    }
    buffer
}

/// Formats a vec of tool calls into a string with nice formatting.
pub fn format_tool_calls_pretty(tool_calls: &[ToolCall]) -> String {
    let mut buffer = String::new();
    writeln!(&mut buffer, "# tool calls:").unwrap();
    for tool_call in tool_calls {
        let call_header = format!("# - Calling `{}`:", tool_call.function_call.name);
        writeln!(&mut buffer, "{call_header}").unwrap();

        let args_str = &tool_call.function_call.arguments;

        let formatted_args = match serde_json::from_str::<serde_json::Value>(args_str) {
            Ok(json_value) => {
                serde_json::to_string_pretty(&json_value).unwrap_or_else(|_| args_str.to_string())
            }
            Err(_) => args_str.to_string(),
        };

        for line in formatted_args.lines() {
            writeln!(&mut buffer, "#   {line}").unwrap();
        }
    }
    buffer
}

/// Checks if a string looks like a unified diff and formats it with colors.
/// Returns `None` if the content is not a diff.
pub fn format_diff(content: &str) -> Option<String> {
    let mut lines = content.lines();
    if !matches!((lines.next(), lines.next()), (Some(f), Some(s)) if f.starts_with("---") && s.starts_with("+++"))
    {
        return None;
    }

    let colored_lines: Vec<String> = content
        .lines()
        .map(|line| {
            if line.starts_with("---") || line.starts_with('-') {
                line.red().to_string()
            } else if line.starts_with("+++") || line.starts_with('+') {
                line.green().to_string()
            } else if line.starts_with("@@") {
                line.cyan().to_string()
            } else {
                line.dimmed().to_string()
            }
        })
        .collect();

    Some(colored_lines.join("\n"))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{config::Config, prompt_builder::build_user_prompt};
    use std::fs;
    use tempfile::Builder;

    #[test]
    fn test_format_diff_valid() {
        let diff_content = "--- a/file.txt\n+++ b/file.txt\n@@ -1 +1 @@\n-red\n+green\nunchanged";
        colored::control::set_override(true);
        let colored = format_diff(diff_content).unwrap();

        assert!(colored.contains(&"--- a/file.txt".red().to_string()));
        assert!(colored.contains(&"+++ b/file.txt".green().to_string()));
        assert!(colored.contains(&"-red".red().to_string()));
        assert!(colored.contains(&"+green".green().to_string()));
        assert!(colored.contains(&"@@ -1 +1 @@".cyan().to_string()));
        assert!(colored.contains(&"unchanged".dimmed().to_string()));

        colored::control::set_override(false);
    }

    #[test]
    fn test_format_diff_invalid() {
        let not_diff_content = "just some regular text\n- with a minus\n+ and a plus";
        assert!(format_diff(not_diff_content).is_none());

        let empty_content = "";
        assert!(format_diff(empty_content).is_none());

        let one_line = "--- a/file.txt";
        assert!(format_diff(one_line).is_none());
    }

    #[tokio::test]
    async fn test_build_and_collapse_prompt() {
        // --- Arrange ---
        let tmp_dir = Builder::new().prefix("test-collapse").tempdir().unwrap();
        let root = tmp_dir.path();

        let file1_path = root.join("test_file.txt");
        let file1_content = "line 1\nline 2\nline 3";
        fs::write(&file1_path, file1_content).unwrap();

        let file2_path = root.join("code.rs");
        let file2_content = "fn main() {\n    println!(\"hello\");\n}";
        fs::write(&file2_path, file2_content).unwrap();

        let config = Config::default();
        let original_prompt = format!(
            "Check these files: @{} and @{}",
            file1_path.display(),
            file2_path.display()
        );

        // --- Act ---
        let expanded_prompt = build_user_prompt(&original_prompt, &config).await.unwrap();

        let message = Message {
            role: "user".to_string(),
            content: expanded_prompt,
            name: None,
            tool_calls: None,
            tool_call_id: None,
        };

        let output = pretty_print_message(&message);

        // --- Assert ---
        // The summary is now colored, so we can't do a simple string comparison.
        // Instead, we verify that the uncolored summary text is present in the output,
        // and that the raw file content has been correctly removed.
        let uncolored_summary_part_1 = format!("[{}", file1_path.display());
        let uncolored_summary_part_2 = "(3 lines)]";

        // Assert that the original prompt appears *before* the file attachments header
        let original_prompt_pos = output.find(&original_prompt).unwrap();
        let attachments_header_pos = output.find("Attached file contents:").unwrap();
        assert!(
            original_prompt_pos < attachments_header_pos,
            "The original prompt should appear before the 'Attached file contents' header."
        );

        assert!(
            output.contains(&uncolored_summary_part_1),
            "Output should contain the file path for file 1.\nOutput was:\n---\n{output}\n---"
        );
        assert!(
            output.contains(uncolored_summary_part_2),
            "Output should contain the line count for file 1.\nOutput was:\n---\n{output}\n---"
        );

        // Assert that the actual file content is NOT in the output
        assert!(
            !output.contains(file1_content),
            "Output should not contain raw content of file 1"
        );
        assert!(
            !output.contains(file2_content),
            "Output should not contain raw content of file 2"
        );

        // Assert that the original prompt text is still there
        assert!(
            output.contains(&original_prompt),
            "Output should still contain the original prompt text"
        );
    }
}

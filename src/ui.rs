use colored::Colorize;
use fancy_regex::Regex;
use once_cell::sync::Lazy;
use openrouter_api::types::chat::Message;
use std::fmt::Write;

static FILE_BLOCK_REGEX: Lazy<Regex> = Lazy::new(|| {
    // This regex captures the file path and content from the block format generated by prompt_builder.
    // (?s) allows . to match newlines.
    Regex::new(r"(?s)### `(?P<path>.+?)`\n```\n(?P<content>.*?)\n```\n---\n?").unwrap()
});

/// Formats a message into a string with nice formatting.
/// It collapses file content blocks for user messages to reduce noise.
pub fn pretty_print_message(message: &Message) -> String {
    let mut buffer = String::new();

    let role_text = message.role.as_str();
    let role_colored = message.role.to_string().blue();
    writeln!(&mut buffer, "\n[{role_colored}]").unwrap();

    // Only for assistant messages that are requesting a tool call.
    if let Some(tool_calls) = &message.tool_calls {
        let _formatted_calls = format_tool_calls_pretty(tool_calls);
        // The output from the tool executor already prints the tool call request,
        // so we don't print it twice. We just process the content.
        // We will just print the content associated with the message, if any.
    }

    if !message.content.is_empty() {
        let is_user = role_text == "user";
        let mut processed_content = message.content.clone();

        if is_user {
            processed_content = FILE_BLOCK_REGEX
                .replace_all(&message.content, |caps: &fancy_regex::Captures| {
                    let path = &caps["path"];
                    let content = &caps["content"];
                    let line_count = content.lines().count();
                    let summary = format!("[{path} ({line_count} lines)]");
                    // Add a newline to ensure each collapsed file is on its own line,
                    // and apply dimming directly.
                    format!("{}\n", summary.dimmed())
                })
                .to_string();
        }

        // The tool executor now handles printing its own colored output directly.
        // So we don't print the content for the 'tool' role here, as it would be a duplicate.
        if role_text != "tool" {
            for line in processed_content.lines() {
                // Pre-colored lines (our summaries) will not be re-colored.
                // Other user prompt lines will be cyan.
                // \x1B is the escape character for ANSI color codes.
                if line.starts_with('\x1B') {
                    writeln!(&mut buffer, "{line}").unwrap();
                } else if role_text == "user" {
                    writeln!(&mut buffer, "{}", line.cyan()).unwrap();
                } else {
                    writeln!(&mut buffer, "{line}").unwrap();
                }
            }
        }
    }
    buffer
}

/// Formats a vec of tool calls into a string with nice formatting.
pub fn format_tool_calls_pretty(tool_calls: &[openrouter_api::models::tool::ToolCall]) -> String {
    let mut buffer = String::new();
    for (i, tool_call) in tool_calls.iter().enumerate() {
        if i > 0 {
            writeln!(&mut buffer).unwrap();
        }
        let call_header = format!("Tool Call: `{}`", tool_call.function_call.name).blue();
        writeln!(&mut buffer, "{call_header}").unwrap();

        let args_str = &tool_call.function_call.arguments;

        let formatted_args = match serde_json::from_str::<serde_json::Value>(args_str) {
            Ok(json_value) => {
                serde_json::to_string_pretty(&json_value).unwrap_or_else(|_| args_str.to_string())
            }
            Err(_) => args_str.to_string(),
        };

        for line in formatted_args.lines() {
            writeln!(&mut buffer, "  {}", line.dimmed()).unwrap();
        }
    }
    buffer
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{config::Config, prompt_builder::build_user_prompt};
    use std::fs;
    use tempfile::Builder;

    #[tokio::test]
    async fn test_build_and_collapse_prompt() {
        // --- Arrange ---
        let tmp_dir = Builder::new().prefix("test-collapse").tempdir().unwrap();
        let root = tmp_dir.path();

        let file1_path = root.join("test_file.txt");
        let file1_content = "line 1\nline 2\nline 3";
        fs::write(&file1_path, file1_content).unwrap();

        let file2_path = root.join("code.rs");
        let file2_content = "fn main() {\n    println!(\"hello\");\n}";
        fs::write(&file2_path, file2_content).unwrap();

        let config = Config::default();
        let original_prompt = format!(
            "Check these files: @{} and @{}",
            file1_path.display(),
            file2_path.display()
        );

        // --- Act ---
        let expanded_prompt = build_user_prompt(&original_prompt, &config).await.unwrap();

        let message = Message {
            role: "user".to_string(),
            content: expanded_prompt,
            name: None,
            tool_calls: None,
            tool_call_id: None,
        };

        let output = pretty_print_message(&message);

        // --- Assert ---
        // The summary is now colored, so we can't do a simple string comparison.
        // Instead, we verify that the uncolored summary text is present in the output,
        // and that the raw file content has been correctly removed.
        let uncolored_summary_part_1 = format!("[{}", file1_path.display());
        let uncolored_summary_part_2 = "(3 lines)]";

        // Assert that the original prompt appears *before* the file attachments header
        let original_prompt_pos = output.find(&original_prompt).unwrap();
        let attachments_header_pos = output.find("Attached file contents:");
        assert!(
            attachments_header_pos.is_none()
                || original_prompt_pos < attachments_header_pos.unwrap(),
            "The original prompt should appear before the 'Attached file contents' header."
        );

        assert!(
            output.contains(&uncolored_summary_part_1),
            "Output should contain the file path for file 1.\nOutput was:\n---\n{output}\n---"
        );
        assert!(
            output.contains(uncolored_summary_part_2),
            "Output should contain the line count for file 1.\nOutput was:\n---\n{output}\n---"
        );

        // Assert that the actual file content is NOT in the output
        assert!(
            !output.contains(file1_content),
            "Output should not contain raw content of file 1"
        );
        assert!(
            !output.contains(file2_content),
            "Output should not contain raw content of file 2"
        );

        // Assert that the original prompt text is still there
        assert!(
            output.contains(&original_prompt),
            "Output should still contain the original prompt text"
        );
    }
}

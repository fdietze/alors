use colored::Colorize;
use fancy_regex::Regex;
use once_cell::sync::Lazy;
use openrouter_api::types::chat::Message;
use std::fmt::Write;

static FILE_BLOCK_REGEX: Lazy<Regex> = Lazy::new(|| {
    // This regex captures the file path and content from the block format generated by prompt_builder.
    // (?s) allows . to match newlines.
    Regex::new(r"(?s)### `(?P<path>.+?)`\n```\n(?P<content>.*?)\n```\n---\n?").unwrap()
});

/// Formats a message into a string with nice formatting.
/// It collapses file content blocks for user messages to reduce noise.
pub fn pretty_print_message(message: &Message) -> String {
    let mut buffer = String::new();

    let role_text = message.role.to_string();
    let role_colored = match role_text.as_str() {
        "tool" => role_text.purple(),
        _ => role_text.blue(),
    };
    writeln!(&mut buffer, "\n[{role_colored}]").unwrap();

    if !message.content.is_empty() {
        let is_user = role_text == "user";
        let mut processed_content = message.content.clone();

        if is_user {
            processed_content = FILE_BLOCK_REGEX
                .replace_all(&message.content, |caps: &fancy_regex::Captures| {
                    let path = &caps["path"];
                    let content = &caps["content"];
                    let line_count = content.lines().count();
                    let summary = format!("[{path} ({line_count} lines)]");
                    // Add a newline to ensure each collapsed file is on its own line,
                    // and apply dimming directly.
                    format!("{}\n", summary.dimmed())
                })
                .to_string();
        }

        for line in processed_content.lines() {
            if line.starts_with('#') {
                writeln!(&mut buffer, "{}", line.dimmed()).unwrap();
            } else if is_user {
                // Pre-colored lines (our summaries) will not be re-colored.
                // Other user prompt lines will be cyan.
                if line.starts_with('\x1B') {
                    writeln!(&mut buffer, "{line}").unwrap();
                } else {
                    writeln!(&mut buffer, "{}", line.cyan()).unwrap();
                }
            } else {
                writeln!(&mut buffer, "{line}").unwrap();
            }
        }
    }

    if let Some(tool_calls) = &message.tool_calls {
        writeln!(&mut buffer, "{}", "# tool calls:".dimmed()).unwrap();
        for tool_call in tool_calls {
            let call_header = format!("# - Calling `{}`:", tool_call.function_call.name);
            writeln!(&mut buffer, "{}", call_header.dimmed()).unwrap();

            let args_str = &tool_call.function_call.arguments;

            let formatted_args = match serde_json::from_str::<serde_json::Value>(args_str) {
                Ok(json_value) => serde_json::to_string_pretty(&json_value)
                    .unwrap_or_else(|_| args_str.to_string()),
                Err(_) => args_str.to_string(),
            };

            for line in formatted_args.lines() {
                writeln!(&mut buffer, "{}", format!("#   {line}").dimmed()).unwrap();
            }
        }
    }
    buffer
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{config::Config, prompt_builder::build_user_prompt};
    use std::fs;
    use tempfile::Builder;

    #[tokio::test]
    async fn test_build_and_collapse_prompt() {
        // --- Arrange ---
        let tmp_dir = Builder::new().prefix("test-collapse").tempdir().unwrap();
        let root = tmp_dir.path();

        let file1_path = root.join("test_file.txt");
        let file1_content = "line 1\nline 2\nline 3";
        fs::write(&file1_path, file1_content).unwrap();

        let file2_path = root.join("code.rs");
        let file2_content = "fn main() {\n    println!(\"hello\");\n}";
        fs::write(&file2_path, file2_content).unwrap();

        let config = Config::default();
        let original_prompt = format!(
            "Check these files: @{} and @{}",
            file1_path.display(),
            file2_path.display()
        );

        // --- Act ---
        let expanded_prompt = build_user_prompt(&original_prompt, &config).await.unwrap();

        let message = Message {
            role: "user".to_string(),
            content: expanded_prompt,
            name: None,
            tool_calls: None,
            tool_call_id: None,
        };

        let output = pretty_print_message(&message);

        // --- Assert ---
        // The summary is now colored, so we can't do a simple string comparison.
        // Instead, we verify that the uncolored summary text is present in the output,
        // and that the raw file content has been correctly removed.
        let uncolored_summary_part_1 = format!("[{}", file1_path.display());
        let uncolored_summary_part_2 = "(3 lines)]";

        assert!(
            output.contains(&uncolored_summary_part_1),
            "Output should contain the file path for file 1.\nOutput was:\n---\n{output}\n---"
        );
        assert!(
            output.contains(uncolored_summary_part_2),
            "Output should contain the line count for file 1.\nOutput was:\n---\n{output}\n---"
        );

        // Assert that the actual file content is NOT in the output
        assert!(
            !output.contains(file1_content),
            "Output should not contain raw content of file 1"
        );
        assert!(
            !output.contains(file2_content),
            "Output should not contain raw content of file 2"
        );

        // Assert that the original prompt text is still there
        assert!(
            output.contains(&original_prompt),
            "Output should still contain the original prompt text"
        );

        // Assert that the "Here is the content" header is still there, but collapsed
        assert!(
            output.contains("Attached file contents:"),
            "Output should contain the intro text"
        );
    }
}
